# TCP/UDP协议

:link: ​[**面试中的TCP/UDP协议**](https://blog.csdn.net/likewind1993/article/details/98382555)

:link: [TCP 重传、滑动窗口、流量控制、拥塞控制](https://mp.weixin.qq.com/s/xe3dEu17mGTqM46LRFxzhg)

UDP报文的**最大长度为512字节**

TCP允许报文长度**超过512字节**

# 重传机制

## 超时重传

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

超时时间不同的情况：

- 当超时时间 **RTO 较大**时，重发就慢，丢了老半天才重发，没有效率，性能差；
- 当超时时间 **RTO 较小**时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

**超时重传时间 RTO 的值应该略大于报文往返  RTT 的值**。

> `RTT` 往返时延，也就是包的往返时间。

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍。**

也就是**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**

## 快速重传

当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

**重传的时候，是重传之前的一个，还是重传所有的问题。**

## SACK

这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将缓存的地图发送给发送方**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

## D-SACK

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

# 滑动窗口

**窗口大小**是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的**处理能力**来发送数据，而不会导致接收端处理不过来。

## 发送方的滑动窗口

![](https://github.com/Eleven-is-cool/img-folder/blob/master/%E5%8F%91%E9%80%81%E6%96%B9%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png?raw=true)

## 接受方的滑动窗口

![](https://github.com/Eleven-is-cool/img-folder/blob/master/%E6%8E%A5%E5%8F%97%E6%96%B9%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png?raw=true)

# 流量控制

**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

# TCP KeepAlive

长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断电、死机、崩溃、重启，还是中间路由网络无故断开，这些**TCP连接并未来得及正常释放**，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，**长时间的积累会导致非常多的半打开连接**，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。所以**服务器端要做到快速感知失败，减少无效链接操作，这就有了TCP的Keepalive（保活探测）机制。**

# 应用层数据很大，怎么进行发送切片

[TCP分段与IP分片](https://blog.csdn.net/ns_code/article/details/30109789)

[来自知乎的一个答案](https://www.zhihu.com/question/22181709)

> 注意：因为 TCP 是在自己这一层执行分片，所以：IP层并不需要再去分片。
>
> 每个TCP分片，都是包含了完整的 TCP 协议头，这样另一方收到包之后，可以方便重组，可以计算出到底哪个分片包丢了，然后**重新传这个分片包**。
>
> 用 UDP 协议发送，那么如果网络发生了波动，丢失了某个 IP 包分片， 对于 UDP 而言， 它没有反馈丢失了哪个分片给发送方的能力，如果需要重传，就得**再次完整**的传递数据。

# 域名中的A记录和CName记录

**A记录**是用来指定主机名（或域名）对应的IP地址记录。

**CNAME记录用作别名**，相当于域名之间的映射（例如 www.baidu.com 映射到 www.a.shifen.com），而不直接与IP地址对应。

# Socket connect和accept

客户端在调用 connect 之后，将开始发起 SYN 请求，请求与服务器建立连接，此时称为第一次握手。

服务器端在接受到 SYN 请求之后，把请求方放入SYN队列中，并给客户端回复一个确认帧 ACK ，此帧还会携带一个请求与客户端建立连接的请求标志，也就是  SYN，这称为第二次握手。

客户端收到 SYN+ACK 帧后，connect 返回，并发送确认建立连接帧 ACK 给服务器端。这称为第三次握手。

服务器端收到 ACK 帧后，会把请求方从 SYN 队列中移出，放至 ACCEPT 队列中，而 accept 函数也等到了自己的资源，从阻塞中唤醒，从 ACCEPT 队列中取出请求方，重新建立一个新的 sockfd，并返回。

这里，在 connect 函数中发生了两次握手。

# 大小端

:link: [socket大小端转换](https://blog.csdn.net/guo8113/article/details/29211243?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param)

