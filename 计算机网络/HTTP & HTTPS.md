# HTTP 方法

|          |      `GET`       |                            `HEAD`                            |                            `POST`                            |                          `PUT`                           |                           `PATCH`                            |
| :------: | :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :------------------------------------------------------: | :----------------------------------------------------------: |
| **作用** |     获取资源     |                         获取报文首部                         |                         传输实体主体                         |                         上传文件                         |                      对资源进行部分修改                      |
| **说明** |                  | 和 GET 方法类似，但是不返回报文实体主体部分。<br />主要用于确认 URL 的有效性以及资源更新的日期时间等。 |                           传输数据                           | 不带验证机制，任何人都可以上传文件，因此存在安全性问题。 | PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 |
|          |                  |                                                              |                                                              |                                                          |                                                              |
|          |   **`DELETE`**   |                        **`OPTIONS`**                         |                        **`CONNECT`**                         |                       **`TRACE`**                        |                                                              |
| **作用** |     删除文件     |                        查询支持的方法                        |               要求在与代理服务器通信时建立隧道               |                         追踪路径                         |                                                              |
| **说明** | 同样不带验证机制 |               查询指定的 URL 能够支持的方法。                | 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 |             服务器会将通信路径返回给客户端。             |                                                              |
|          |                  |                                                              |                                                              |                                                          |                                                              |

# HTTP 状态码

![HTTP state](https://github.com/Eleven-is-cool/img-folder/blob/master/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81.png?raw=true)

# HTTP 报文结构

HTTP 报文有 **请求报文** 和 **响应报文** 两种。

**请求报文**：从客户向服务器发送请求报文。

**响应报文**：从服务端到客户的回答。

HTTP的这两种报文都由三部分组成：**开始行**、**首部行**、**实体主体**。

## 一、开始行

#### 请求报文的开始行

> 也叫**请求行**，由 **方法**、**[空格]**、**URL**、**[空格]**、**HTTP版本** 组成。

**方法**： 向请求资源指定的资源发送请求报文的方法，其作用是可以指定请求的资源按期望产生某种行为。

**URL** : 链接

**HTTP版本**：目前有 HTTP/1.0、HTTP/1.1、HTTP/2.0 版本，其中 HTTP1.0 版本使用较广泛

#### 响应报文的开始行

> 也叫**响应行**，由 **HTTP 版本**、**[空格]**、**状态码**组成。

## 二、首部行

1. 是用来**说明浏览器、服务器或报文主体的一些信息。**

2. 可以有好几行，也可以不使用

3. 每个首部行都是由 **首部字段名**、**[空格]** 和 **值** 组成

4. 每个首部行在结束地方都有 `CRLF`（『回车』和『换行』符）

HTTP 首部字段分为 4 种： **通用首部字段**、**请求首部字段**、**响应首部字段**、**实体首部字段**。

## 三、实体主体

在请求报文中，一般是 post/put 提交的表单信息。与首部行之间有 `CRLF` 即空行。

# HTTPS

:link: [HTTPS](https://blog.csdn.net/qq_38289815/article/details/80969419?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param)

# HTTPS 验证两端身份

1. 客户端向一个需要**https访问的网站发起请求**。

2. 服务器将**证书发送给客户端进行校验**。证书里面包含了其**公钥**。这里要特别说一下客户端底如何来校验对方发过来的**数字证书是否有效。**

   a. 首先在**本地电脑寻找是否有这个服务器证书上的ca机构的根证书**。如果有继续下一步，如果没有弹出警告。

   b. 使用**ca机构根证书的公钥对服务器证书的指纹和指纹算法进行解密**。

   c. **得到指纹算法**之后，拿着这个**指纹算法对服务器证书的摘要进行计算得到指纹**。

   d. 将计算出的**指纹**和从服务器证书中**解密出的指纹**对比看是否一样，如果一样则**通过认证**。

3. 校验成功之后，客户端会生成一个**随机串**然后使用**服务器证书的公钥进行加密**之后**发送给服务器**。

4. 服务器通过使用自己的**私钥解密得到这个随机值**。

5. 服务器从此开始使用这个**随机值**进行**对称加密**，开始和客户端进行通信。

6. 客户端拿到值用**对称加密方式**，使用随机值进行**解密**。

为什么不一直使用非对称进行加密，而是在类似握手之后开始使用对称加密算法进行https通信：

**非对称加密的消耗和所需的计算以及时间远比对称加密消耗要大，所以在握手和认证之后，服务器和客户端就开始按照约定的随机串，对后续的数据传输进行加密。**

# HTTPS1.0 & HTTPS1.1 & HTTPS2.0

|              http1.0              |             http1.1             |                  http2.0                   |
| :-------------------------------: | :-----------------------------: | :----------------------------------------: |
| 一个连接上只能获得**一个web**资源 | 一个连接上可获取**多个web**资源 |           解析采用**二进制**格式           |
|                                   |         默认支持长连接          | **多路复用**，在一个连接并行的处理多个请求 |
|                                   |          解析基于文本           |                                            |
|                                   |   新增24个**错误状态响应码**    |                                            |

# GET与POST

|                      |                             GET                              |                             POST                             |
| :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    后退按钮/刷新     |                             无害                             |   数据会被重新提交（浏览器应该告知用户数据会被重新提交）。   |
|         书签         |                         可收藏为书签                         |                        不可收藏为书签                        |
|       **缓存**       |                         **能被缓存**                         |                         **不能缓存**                         |
|       编码类型       |              application/x-www-form-urlencoded               | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
|         历史         |                   参数保留在浏览器历史中。                   |                 参数不会保存在浏览器历史中。                 |
| **对数据长度的限制** | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 |                         **无限制。**                         |
| **对数据类型的限制** |                   **只允许 ASCII 字符。**                    |               **没有限制。也允许二进制数据。**               |
|      **安全性**      | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
|      **可见性**      |              数据在 URL 中对所有人都是可见的。               |                   数据不会显示在 URL 中。                    |

# Session

## session 分布式处理

服务分布在不同的服务器，会让同一个用户频繁登录。

五种Session处理策略：[分布式环境下5种session处理策略](https://my.oschina.net/u/1774673/blog/871912)

# DNS

![img](https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg)

1. 本地DNS服务器（一般都是你的网络接入服务器商提供，比如中国电信，中国移动），本地DNS服务器会**首先查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果。
2. 如果没有，本地DNS服务器还要向**DNS根服务器**进行查询。DNS根服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出**域服务器的地址**。
3. 本地DNS服务器继续向**域服务器**发出请求，例如：请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是**告诉本地DNS服务器**，你的**域名的解析服务器的地址**。
4. **最后，本地DNS服务器向域名的解析服务器发出请求**，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

具体可描述如下：

1. 主机先向本地域名服务器进行递归查询

2. 本地域名服务器采用迭代查询，向一个根域名服务器进行查询

3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址

4. 本地域名服务器向顶级域名服务器进行查询

5. 顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址

6. 本地域名服务器向权限服务器进行查询

7. 权限服务器告诉本地域名服务器所查询的主机的IP地址

8. 本地域名服务器最后把查询结果告诉主机

**关于DNS解析的TTL参数：**

我们在配置DNS解析的时候，有一个参数常常容易忽略，就是DNS解析的TTL参数，**Time To Live**。TTL这个参数告诉本地DNS服务器，**域名缓存的最长时间。**

**DNS使用UDP还是TCP：**

客户端向DNS服务器查询域名，一般返回的**内容都不超过512字节**，用**UDP**传输即可。不用经过TCP三次握手，这样DNS服务器**负载更低**，**响应更快**。

# 对称与非对称加密算法

:link: [常用的加密方式和应用场景](http://jackzhang.info/2019/04/16/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/)

**一、对称加密算法** 

> 优点：**算法简单**和**加密速度快**
>
> 缺点：安全性差

**DES（Data Encryption Standard）**：数据加密标准，速度较快，适用于加密大量数据的场合。**密钥长度较短，已经不适合当今分布式开放网络对数据加密安全性的要求。**

**3DES（Triple DES）**：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。

**AES（Advanced Encryption Standard）**：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；

**二、非对称加密算法**

**RSA：**由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；RSA算法是最流行的公钥密码算法，**使用长度可以变化的密钥**。RSA是第一个既能用于**数据加密**也能用于**数字签名**的算法。

**DSA（Digital Signature Algorithm）**：数字签名算法，是一种标准的 DSS（数字签名标准）；

**ECC（Elliptic Curves Cryptography）**：椭圆曲线密码编码学。

# CSRF攻击

[前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)