# <span style = 'color:#45B39D'>基础知识</span>

## 面向对象的特征

抽象，封装，继承，多态。 

**抽象**：是将一类对象的共同特征总结出来构造类的过程。

**封装**：把描述一个对象的属性和行为封装成一个类。（类中有静态static块，做类初始化工作，执行在new之前）

**继承**：extends继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或类从父类继承方法，使得子类具有父类相同的行为。（private、构造方法不被继承、java无多继承）

**多态**：多态性是指允许相同或不同子类型的对象对来自父类的同一消息作出不同响应。**条件：继承、重写、父类引用指向子类对象。**

## **重载和重写的区别**

**方法重载**：是让类以统一的方式处理不同类型数据的一种手段。多个**同名函数**同时存在，**具有不同的参数个数或者参数类型**。

**方法重写**（多态性）：方法覆盖，父类与子类之间的多态性，对父类的函数进行重新定义（**函数名称相同，参数相同**）。

## 抽象类和接口有什么区别

抽象类 `abstract void function();`  它不能被实例化，只能被继承，用来捕捉子类的通用特性的。

接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。用`implements`来实现接口。

> 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
>
> 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。

## 基本类型

| 数据类型  |                       存储空间（bit）                        |             默认值              |
| :-------: | :----------------------------------------------------------: | :-----------------------------: |
|  `byte`   |                              8                               |             (byte)0             |
|  `char`   |                              16                              | '\u0000'（对应数字0，输出为空） |
|  `short`  |                              16                              |            (short)0             |
|   `int`   |                              32                              |                0                |
|  `float`  |                              32                              |              0.0F               |
|  `long`   |                              64                              |               0L                |
| `double`  |                              64                              |              0.0D               |
| `boolean` | boolean 只有两个值：true、false，可以使用 1 bit 来存储，<br />但是具体大小没有明确规定。<br />JVM 会在编译时期将 boolean 类型的数据转换为 int，<br />使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，<br />但是是通过读写 byte 数组来实现的。 |              flase              |

## 缓存池

`Integer` 的 `valueOf` 方法判断变量是否在缓存池中，如果在的话就直接返回缓存池的内容。

`new Integer(123) `与 `Integer.valueOf(123) `的区别在于：

- `new Integer(123) `每次都会新建一个对象；
- `Integer.valueOf(123) `会使用缓存池中的对象，多次调用会取得同一个对象的引用。

> Integer 缓存池的大小默认为 **-128~127**，最大值可以更改。
>
> short 缓存池的大小默认为 **-128~127**。
>
> char 缓存池的大小默认为  **\u0000~\u007F**。 
>
> byte 缓存池所有

编译器会在自动装箱过程调用 `valueOf()` 方法，因此多个值相同且值在缓存池范围内的 `Integer` 实例使用自动装箱来创建，那么就会引用相同的对象。

```java
🌰
Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
```

> 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。

## `>>` 和 `<<` 

> :rotating_light: ​`>>` 和 `<<` 是将**补码**进行左移右移。

`反码`：1. 正数：反码是其本身

​			2. 负数：符号位不变，其余各个位取反

`补码`：1. 正数：补码是其本身

​            2. 负数：反码加一

`>>`：原值补码右移n位 = 除以2^n^

`<<`：原值补码左移n位 = 乘以2^n^

## `n & (n - 1)`

作用：**消除**最后一个 1

> **其核心逻辑就是，`n - 1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 `n` 做一次 `&` 运算，就可以仅仅把最后一个 1 变成 0 了。**

## `final`

[来自简书：你以为你真的了解final吗？](https://www.jianshu.com/p/1f4b0f98cbf1)

`final`能够修饰变量，方法和类。

1. 变量

   **静态变量**：必须要在**静态初始化块**中指定初始值或者**声明该类变量时**指定初始值，而且只能在这**两个地方**之一进行指定；

   **实例变量**：必要要在**非静态初始化块**，**声明该实例变量**或者在**构造器中**指定初始值，而且只能在这**三个地方**进行指定。

   **当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的**。

2. 方法

   当父类的方法被 `final` 修饰的时候，子类不能重写父类的该方法。

   `final` 方法是可以被重载。

3. 类

   **当一个类被final修饰时，表名该类是不能被子类继承的**。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患。

## 访问控制符

|             | 类内部 | 当前包 | 子类 | 外部包 |
| :---------: | :----: | :----: | :--: | :----: |
|  `public`   |   √    |   √    |  √   |   √    |
| `protected` |   √    |   √    |  √   |   ×    |
|  `private`  |   √    |   ×    |  ×   |   ×    |

##  `final`, `finally`, `finalize` 的区别

`final`：标识符，指变量或者是方法被声明为final后，变量在之后的引用中只能读取，不可修改，方法只能使用，不能重写。

`finally`：关键字，异常处理中使用，搭配catch，finall块中无论异常是否发生，都会执行。

`finalize`：方法，finalize（）是在object类中的方法，使用该方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。		

## `String` 不可变的好处

 ```java
public final class String
  implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    // value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。
    private final byte[] value;
    
  	/** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;// 标识编码
}
 ```

**1. 可以缓存 hash 值**

因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

**2. String Pool 的需要**

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。

<img src="https://github.com/Eleven-is-cool/img-folder/blob/master/%E5%B8%B8%E9%87%8F%E6%B1%A0.png?raw=true" alt="img" style="zoom:50%;" />

**3. 安全性**

String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。

**4. 线程安全**

String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

## `String` 的 `intern()`

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2); // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4); // true
```

s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。

`intern()` **首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。 **因此 s3 和 s4 引用的是同一个字符串。

如果是采用 "bbb" 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。

```java
String s5 = "bbb";
String s6 = "bbb";
System.out.println(s5 == s6);  // true
```

在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

## `new String("abc")`

使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象，否则就直接在堆中创建一个对象）。

- "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
- 而使用 new 的方式会在堆中创建一个字符串对象。

## 隐式类型转换

Java 不能隐式执行向下转型，因为这会使得精度降低。

因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。但是使用 += 或者 ++ 运算符会执行隐式类型转换。

```java
short s1 = 1;
s1 += 1;
s1++;
// 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：
s1 = (short) (s1 + 1);
```

## `StringBuilder`、`StringBuffer`的实现与使用区别

`String`类是不可变类，任何对String的改变都 会引发新的`String`对象的生成；
`StringBuffer`则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。

`StringBufferd`支持并发操作，**线性安全的**，适合多线程中使用;
`StringBuilder`不支持并发操作，**线性不安全的**，不适合多线程中使用。
​新引入的`StringBuilder`类不是线程安全的，但其在单线程中的性能比`StringBuffer`高。

##  `Integer`范围

 `MIN_VALUE` = -2^31^         `MAX_VALUE` = 2^31^-1.

## `int` 和 `Integer` 有什么区别

java中数据类型分为基本数据类型和复杂数据类型。

`int` 是基本类型，直接存数值，而 `integer` 是对象（复杂数据类型），用一个引用指向这个对象。

`Integer i= new Integer(1);`(要把integer 当做一个类看)，但由于有了**自动装箱和拆箱**使得对 `Integer` 类也可使用：`Integer i= 1;`

> **装箱**：将基本数据类型封装为对象类型，来符合java的面向对象；
>
> **拆箱**：将对象重新转化为基本数据类型，因为对象不能直接进行运算
>
> 当需要往`ArrayList`，`HashMap`中放东西时，像`int`，`double`这种内建类型是放不进去的，因为容器都是装 object的，这是就需要这些内建类型的外覆类了。

## `equals` 与 `==` 的区别

`== `  运算符所进行的是所引用对象的内存地址是否一致

`equals()`方法是String类中的方法，其所进行的是两个对象引用所指的内容是否相同的比较

- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
- 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。

## 静态变量

存在继承的情况下，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

## Java支持goto吗

Java**不支持**goto，它被保留为关键字，以防他们想将其添加到更高版本。

- 与C / C ++不同，Java没有goto语句，但是java支持标签。
- 在嵌套循环语句之前，Java中唯一有用的地方就是它。
- 我们可以使用break来指定标签名称以打破特定的外部循环。
- 同样，可以继续指定标签名称。

## "ab" + "cd"

new 了一个 **StringBuilder** 对象，然后**使用 `append` 方法**优化了 `+` 操作符。

:rotating_light:  不在循环体中使用 `+` ：new一个 **StringBuilder**  对象，进行 `append` 操作，最后通过 `toString( )` 返回 `String` 对象，**造成内存资源的浪费**。

## `this`

`this` 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

普通的直接引用

形参与成员名字重名，用this来区分

## `super`

`super` 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。

1. 主要存在于子类方法中，用于指向子类对象中父类对象。

2. 访问父类的**属性**

3. 访问父类的**函数**

4. 访问父类的**构造函数**

## Comparable接口与Comparator接口的区别

|              Comparable接口               |                     Comparator接口                     |
| :---------------------------------------: | :----------------------------------------------------: |
|            定义在类的**内**部             |                   定义在类的**外**部                   |
| 实现Comparable接口要覆盖**compareTo**方法 |        实现Comparator需要覆盖 **compare** 方法         |
|      Collections.sort( personList )       | Collections.sort( personList , new PersonComparator()) |
|          需要改动源码来进行比较           |               实现一个比较器不用改动源码               |

使用Comparator进行**二次排序**，来自美团的一道笔试题。

```java
class Event{
    int id;
    int priority;
    int necessity;
    public Event(int id, int priority, int necessity){
        this.id = id;
        this.priority = priority;
        this.necessity = necessity;
    }
}    
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    while (sc.hasNext()) {
        int n = sc.nextInt();
        Event[] events = new Event[n];
        for (int i = 0; i < n; i++){
            events[i] = new Event(i+1, sc.nextInt(), sc.nextInt());
        }
        Arrays.sort(events,(a,b)->{
            if (a.necessity != b.necessity){
                return b.necessity - a.necessity;
            }else{
                return b.priority - a.priority;
            }
        });
        for (int i = 0; i < n; i++){
            if (i == n-1){
                System.out.print(events[i].id);
            }else{
                System.out.print(events[i].id + " ");
            }
        }
    }
}
```

## JVM、JRE、 JDK

- **JVM**：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。

  > **什么是字节码?采用字节码的好处是什么?**
  >
  > 在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

- **JRE**：Java Runtime Environment，Java 运行环境的简称，**为 Java 的运行提供了所需的环境**。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。

- **JDK**：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。**JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具**，比如编译 Java 源码的编译器 javac 等。

## 泛型

1. **Java中的泛型是什么 ? 使用泛型的好处是什么?**

   它提供了**编译期的类型安全**，确保你只能把正确类型的对象放入集合中，避免了在运行时出现`ClassCastException`。

2. **Java的泛型是如何工作的 ? 什么是类型擦除 ?**

   泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 `List<String>` 在运行时仅用一个 List 来表示。这样做的目的，是**确保能和Java 5之前的版本开发二进制类库进行兼容**。**你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。**

3. **什么是泛型中的限定通配符和非限定通配符 ？**

   限定通配符对类型进行了限制。有两种限定通配符，一种是 `<? extends T>` 它通过确保类型必须是T的子类来设定类型的**上界**，另一种是 `<? super T>` 它通过确保类型必须是T的父类来设定类型的**下界**。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。

   另一方面 `<?>` 表示了非限定通配符，因为 `<?>` 可以用任意类型来替代。

4. **`List<? extends T>` 和 `List <? super T>` 之间有什么区别 ？**

   `List<? extends T>`可以接受任何继承自T的类型的List，而`List<? super T>`可以接受任何T的父类构成的List。例如`List<? extends Number>`可以接受`List<Integer>`或`List<Float>`。

5. **如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型？**

   ```java
   public V put(K key, V value) {
       return cache.put(key, value);
   }
   ```

6. **`List<Object>` 和原始类型 `List` 之间的区别？**

   原始类型和带参数类型 `<Object>` 之间的主要区别是，**在编译时编译器不会对原始类型进行类型安全检查**，却会对带参数的类型进行检查，通过使用` Object `作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。

7. **你可以把`List<String>`传递给一个接受`List<Object>`参数的方法吗？**

   不可以，可以把任何带参数的泛型类型传递给接受原始类型List的方法，但却不能把 `List<String>` 传递给接受 `List<Object>` 的方法

8. **`List<?>`和`List<Object>`之间的区别是什么？**

   `List<?>` 是一个未知类型的 `List` ，而 `List<Object>` 其实是任意类型的 `List` 。你可以把 `List<String>, List<Integer>` 赋值给 `List<?>` ，却不能把 `List<String>` 赋值给 `List<Object>` 。  

9. **Array中可以用泛型吗？**

   不能。

## 深拷贝和浅拷贝

**浅拷贝**：拷贝对象和原始对象的引用类型引用同一个对象。

**深拷贝**：拷贝对象和原始对象的引用类型引用不同对象，**创建一个新的对象**，**并复制其内容**，此为深拷贝。

![deep and shallow copy](https://camo.githubusercontent.com/d6d8355e9c0cbde0bdf8a53d34b0e2b46bbaa5e7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f6a6176612d646565702d616e642d7368616c6c6f772d636f70792e6a7067)

## 说说反射的用途及实现

每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。

反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁，定义在`java.lang.relfect`中。

反射机制提供的功能主要有：

1. 得到一个对象所属的类；
2. 获取一个类的所有成员变量和方法；
3. 在运行时创建对象；
4. 在运行时调用对象的方法。

[反射和注解](http://cool-eleven.cn/2020/02/25/Java反射/)

## 说说自定义注解的场景及实现

> 1. 类属性自动赋值。
>
> 2. 验证对象属性完整性。
>
> 3. 代替配置文件功能。
>
> 4. 可以生成文档。

1. `@Target(xxx)` 用来说明该自定义注解可以用在什么位置，比如

   `ElementType.FIELD`：说明自定义的注解可以用于类的变量       

   `ElementType.METHOD`：说明自定义的注解可以用于类的方法        

   `ElementType.TYPE`：说明自定义的注解可以用于类本身、接口或 enum类型          

2. `@Retention(xxx)` 用来说明你自定义注解的生命周期，比如：      

   `@Retention(RetentionPolicy.RUNTIME)`：表示注解可以一直保留到运行时，因此可以通过反射获取注解信息        

   `@Retention(RetentionPolicy.CLASS)`：表示注解被编译器编译进 class文件，但运行时会忽略        

   `@Retention(RetentionPolicy.SOURCE)`：表示注解仅在源文件中有效，编译时就会被忽略

   所以声明周期从长到短分别为：RUNTIME > CLASS > SOURCE ，一般来说，如果需要在运行时去动态获取注解的信息，还是得用RUNTIME，就像本文所用。       

3.  `@Document` 注解用途主要是标识类型是否要被收入javadoc      

4.  `@Inherited` 使被它修饰的注解具有继承性（如果某个类使用了被`@Inherited`修饰的注解，则其子类将自动具有该注解）

## 文件与 I\O 流

1. Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；

- 按照操作单元划分，可以划分为字节流和字符流；

- 按照流的角色划分为节点流和处理流。

2. Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

   InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
   OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

3. 既然有了字节流,为什么还要有字符流?

   字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

4. **IO流中的设计模式**

   :link:[Java IO 流涉及的设计模式](https://www.jianshu.com/p/933631bc5e20)

## 异常

**Error：**

1. Error类对象由Java虚拟机生成并抛出。

2. Error类层描述了java运行时系统内部错误和资源耗尽错误

**Exception：**

1. Exception类对象由应用程序处理或抛出。

2. Exception层次结构分为两个分支：

   ① RuntimeException：由程序错误导致的异常。如错误的类型转换、数组访问越界、访问 Null指针。“如果出现RuntimeException异常，那么一定是你的问题”;

   ② 其他异常：程序本身没有问题，但由于像I/O错误这类异常问题属于其他异常。例如：试图在文件尾部读取数据、试图打开一个不存在的文件等。

> **Error和RuntimeException为非受检查异常，其它异常为受检查异常**

## 引用、指针和句柄的区别

**句柄**是一种特殊的智能指针 。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的**内存块或对象**时，就要使用句柄。

**句柄与普通指针的区别在于**，**指针包含的是引用对象的内存地址**，而**句柄则是由系统所管理的引用标识**，**该标识可以被系统重新定位到一个内存地址上**。这种**间接访问对象的模式增强了系统对引用对象的控制。**

当把硬盘上的资源调入内存以后，将有一个句柄指向它，但是**句柄**只能**指向一个资源**。而且**句柄知道所指的内存有多大**。

**指针**指向地址，**标记某个物理内存的地址，它不知道分配的内存有多大**。

**引用是一个变量的别名**（**内存空间的名字**），本身不单独分配自己的内存空间

## 可解释性语言与编译性语言

#### **编译性语言**

编译型语言写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。

#### **解释性语言**

解释则不同，**解释性语言的程序不需要编译**，省了道工序，解释性语言在运行程序的时候才翻译，比如解释性java语言，专门有一个解释器能够直接执行java程序，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就要翻译一次，效率比较低。

Java语言是特殊的**解释性语言**。java程序同样需要编译，但是没有直接编译称为机器语言，而是编译为**字节码**，然后用**解释方式执行字节码**。**Java既可以被编译，也可以被解释。**通过编译器，可以把Java程序翻译成一种中间代码 - 称为字节码 - 可以被Java解释器解释的独立于平台的代码。通过解释器，**每条Java字节指令被分析，然后在计算机上运行。只需编译一次，程序运行时解释执行，实现跨平台功能。**

## 内部类

:link: [Java中的四种内部类](https://www.jianshu.com/p/3ec6aa56fe6a)

## 匿名类

```java
new 父类构造器（参数列表）|实现接口（）  
{  
    //匿名内部类的类体部分  
}
```

1. 使用匿名内部类我们必须要继承一个父类或者实现一个接口。
2. 没有 class 关键字
3. 匿名内部类中是不能定义构造函数的。
4. 匿名内部类中不能存在任何的静态成员变量和静态方法。
5. 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
6. 不能访问**外层方法**中的本地变量。除非变量是 final。
7. 可以访问外层 Class 里面的字段

