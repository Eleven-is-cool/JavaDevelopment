# <span style = 'color:#45B39D'>Mysql</span>

## 约束

1. 主键约束（Primay Key Coustraint） 唯一性，非空性
2. 外键约束 （Foreign Key Counstraint）需要建立两表间的关系并引用主表的
3. 唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个
4. 默认约束 （Default Counstraint）该数据的默认值
5. 检查约束 （Check Counstraint）对该列数据的范围、格式的限制 （如：年龄、性别等）

## 三大范式

1. **第一范式**

   确保每列保持原子性，无表中表。

2. **第二范式**

   对记录的唯一性，**非主键字段必须依赖主键**，确保表中的每列都和主键相关。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

3. **第三范式**

   对字段的冗余性，确保**每列都和主键列直接相关**，而不是间接相关。

## 什么是事务?

事务是逻辑上的一组操作，要么都执行，要么都不执行。

## 事务的四大特性(ACID)

1. **原子性（Atomicity）**： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性（Consistency）**：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
3. **隔离性（Isolation）**：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性（Durability）**：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## MySQL数据类型

主要包括以下五大类：

**整数类型**：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT

**浮点数类型**：FLOAT、DOUBLE、DECIMAL

**字符串类型**：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB

**日期类型**：Date、DateTime、TimeStamp、Time、Year

**其他数据类型**：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等

## 系统的三级模式结构

数据库系统的三级模式结构是指数据库系统由外模式、模式和内模式三级构成。

- **模式**：也称逻辑模式，数据库中全体数据的逻辑结构和特征的描述，所有用户的公共数据视图。

  一个数据库只有一个模式。

  模式是数据库系统模式结构的中间层。

- **外模式**：也称子模式或用户模式，数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述， 是与某一应用有关的数据的逻辑表示。

  外模式介于模式与应用之间，外模式通常是模式的子集。

  外模式与应用的关系也是一对多的关系，同一外模式也可以为某一用户的多个应用系统所使用， 但一个应用程序只能使用一个外模式。

- **内模式**：也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。

  一个数据库只有一个内模式。

**Ⅰ 外模式/模式映象**

定义外模式与模式之间的对应关系； 每一个外模式都对应一个外模式/模式映象；

映象定义通常包含在各自外模式的描述中；

当模式改变时，数据库管理员修改相关的外模式/模式映象，使外模式不变， 语言程序是依据数据的外模式编写的，从而应用程序不必修改， 保证了数据与程序的逻辑独立性，简称数据的**逻辑独立性**。

**Ⅱ 模式/内模式映象**

定义数据全局逻辑结构与存储结构之间的对应关系；

数据库中模式/内模式映象是唯一的；

通常包含在模式描述中；

当数据库的存储结构改变了，数据库管理员修改模式/内模式映象，使模式保持不变， 应用程序不受影响，保证了数据与程序的**物理独立性**。

## sql语法

:link: [SQL教程](https://www.runoob.com/sql/sql-alter.html)

:link: [一千行MySQL命令.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/一千行MySQL命令.md)

```sql
🌰
// 从 m+1 开始取 n 条 
limit m,n
// 查找两门成绩大于80的学生的名字
select name from Student where score>80 group by name having count(*)>=2
// 查找成绩前几名的学生名字
select name from Student order by score desc limit 3
// 产品价格总和大于100的产品
select product,sum(price) from orders GROUP BY product HAVING sum(price)>100
// 添加索引
ALTER TABLE table_name ADD INDEX index_name (column_list)
CREATE INDEX index_name ON table_name (column_list)
```

## MySQL 索引使用的注意事项

[注]：以下有好几条重复的。

- 索引不会包含有 `NULL` 的列 只要列中包含有 `NULL` 值，都将不会被包含在索引中，复合索引中只要有一列含有 `NULL` 值，那么这一列对于此复合索引就是无效的。
- 使用短索引 对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个 `char（255）` 的列，如果在前 `10` 个或 `20` 个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 `I/O` 操作。
- 索引列排序 MySql 查询只使用一个索引，因此如果 `where` 子句中已经使用了索引的话，那么 `order by` 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。
- **最左前缀**：`like` 语句操作 一般情况下不鼓励使用 `like` 操作，如果非使用不可，注意正确的使用方式。`like ‘%aaa%’` 不会使用索引，而 `like ‘aaa%’` 可以使用索引。
- 不要在列上进行运算
- 不使用 `NOT IN` 、`<>`、`！=`操作，但 `<` , `<=` ，`=` ，`>` , `>=` , `BETWEEN` , `IN` 是可以用到索引的
- 索引要建立在经常进行select操作的字段上。这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
- 索引要建立在值比较唯一的字段上
- 对于那些定义为 `text`、`image` 和 `bit` 数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少
- 在 `where` 和 `join` 中出现的列需要建立索引
- `where` 的查询条件里有不等号 `(where column != …)` , MySql 将无法使用索引
- 如果 `where` 字句的查询条件里使用了函数(如：`where DAY(column)=…)`, MySql 将无法使用索引
- 在 `join` 操作中(需要从多个数据表提取数据时)，MySql 只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用、

## Join 语句的作用

合理使用Join语句优化SQL有利于：

1. 增加数据库的处理效率，减少响应时间；
2. 减少数据库服务器负载，增加服务器稳定性；
3. 减少服务器通讯的网络流量；

## Join 的实现原理

Join 的实现是采用 Nested Loop Join 算法，就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果有多个 Join，则将前面的结果集作为循环数据，再一次作为循环条件到后一个表中查询数据。

## Join 语句的优化原则

1. **用小结果集驱动大结果集**，将筛选结果小的表首先连接，再去连接结果集比较大的表，尽量减少join语句中的Nested Loop的循环总次数；
2. **优先优化Nested Loop的内层循环**（也就是最外层的Join连接），因为内层循环是循环中执行次数最多的，每次循环提升很小的性能都能在整个循环中提升很大的性能；
3. 对被驱动表的join字段上建立**索引**；
4. 当被驱动表的join字段上无法建立索引的时候，设置**足够的Join Buffer Size**。

## 内连接和外连接、左连接和右连接

1. **INNER JOIN （内连接）**：内连接是一种一一映射关系，就是两张表都有的才能显示出来

   ![这里写图片描述](https://github.com/Eleven-is-cool/img-folder/blob/master/%E5%86%85%E8%BF%9E%E6%8E%A5.png?raw=true)

2. **LEFT JOIN （左连接）**：左连接是左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分只能补空显示，所谓的左边表其实就是指放在 left join 的左边的表。

   ![这里写图片描述](https://github.com/Eleven-is-cool/img-folder/blob/master/%E5%B7%A6%E8%BF%9E%E6%8E%A5.png?raw=true)

   ```sql
   SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value
   FROM table_a A
   LEFT JOIN  table_b B
   ON A.PK = B.PK;
   ```

3. **RIGHT JOIN（右连接）**：右连接正好是和左连接相反的，这里的右边也是相对right join来说的，在这个右边的表就是右表。

   ![这里写图片描述](https://github.com/Eleven-is-cool/img-folder/blob/master/%E5%8F%B3%E8%BF%9E%E6%8E%A5.png?raw=true)

   ```sql
   SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value
   FROM table_a A
   RIGHT JOIN  table_b B
   ON A.PK = B.PK;
   ```

4. **OUTER JOIN（外连接、全连接）**：查询出左表和右表所有数据，但是去除两表的重复数据。

## 说说反模式设计

简单的来说，反模式是指在对经常面对的问题经常使用的低效，不良，或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。

## 说说分库与分表设计

### 垂直分表

垂直分表是指某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。

### 垂直分库

垂直分库是按照业务模块来划分出不同的数据库。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。

### 水平分表

水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中，这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。

### 水平分库

水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。

## 分库与分表带来的分布式困境与应对之策

[分库与分表带来的分布式困境与应对之策](https://blog.csdn.net/jiangpingjiangping/article/details/78069480)

## 说说 SQL 优化之道

[SQL优化之道](https://www.jianshu.com/p/906fd3ca8dc7)

## 并发事务带来哪些问题

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

:fallen_leaf: **不可重复读和幻读区别：**

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

## 事务隔离级别有哪些?MySQL的默认隔离级别是?

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

------

| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
| ---------------- | ---- | ---------- | ------ |
| READ-UNCOMMITTED | √    | √          | √      |
| READ-COMMITTED   | ×    | √          | √      |
| REPEATABLE-READ  | ×    | ×          | √      |
| SERIALIZABLE     | ×    | ×          | ×      |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。

## MySQL 遇到的死锁问题

产生死锁的四个必要条件：

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 下列方法有助于最大限度地降低死锁：

- 按同一顺序访问对象。
- 避免事务中的用户交互。
- 保持事务简短并在一个批处理中。
- 使用低隔离级别。
- 使用绑定连接。

## 存储引擎的 InnoDB 与 MyISAM

[MySQL索引背后的数据结构及算法原理](https://www.jianshu.com/p/fae74b6a54e3)

- **MyISAM:** B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
- **InnoDB:** 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。** **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。**

**两者的对比：**

1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

2. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

3. **是否支持外键：** MyISAM不支持，而InnoDB支持。

4. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;MVCC可以使用乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。

## MVCC

[MVCC](https://segmentfault.com/a/1190000012650596)

[MVCC](https://www.cnblogs.com/kismetv/p/10331633.html)

MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：

1）隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。

2）基于undo log的版本链：前面说到每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。

3）ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。

trx_sys中的主要内容，以及判断可见性的方法如下：

**low_limit_id**：表示生成ReadView时系统中应该分配给下一个事务的id。如果数据的事务id大于等于low_limit_id，则对该ReadView不可见。

**up_limit_id**：表示生成ReadView时当前系统中活跃的读写事务中最小的事务id。如果数据的事务id小于up_limit_id，则对该ReadView可见。

**rw_trx_ids**：表示生成ReadView时当前系统中活跃的读写事务的事务id列表。如果数据的事务id在low_limit_id和up_limit_id之间，则需要判断事务id是否在rw_trx_ids中：如果在，说明生成ReadView时事务仍在活跃中，因此数据对ReadView不可见；如果不在，说明生成ReadView时事务已经提交了，因此数据对ReadView可见。

## 数据库索引的原理

没有索引，全盘扫描。    

使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。    

一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构 。   

索引中除了存储列的值，还存储着一个指向在行数据的索引(那行数据在硬盘上的地址)。    
`CREATE INDEX name_index ON Employee (Employee_Name, Employee_Age) `  

使用数据库索引的缺点：

其一，索引会占用空间 - 你的表越大，索引占用的空间越大。

其二，性能损失（主要值更新操作），当你在表中添加、删除或者更新行数据的时候， 在索引中也会有相同的操作。

基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引。

## 索引种类

索引的种类这里只罗列出InnoDB支持的索引：**主键索引(PRIMARY)，普通索引(INDEX)，唯一索引(UNIQUE)，组合索引，**总体划分为两类，**主键索引**也被称为聚簇索引（clustered index），其余都称呼为**非主键索引**也被称为二级索引（secondary index）。

**主键索引 和 非主键索引**

区别在与叶子节点中，主键索引存储了**整行数据**，而**非主键索引中存储的值为主键id**。

## 回表

**在流程中从非主键索引树搜索回到主键索引树搜索的过程称为：回表**，在查询中因为查询结果只存在主键索引树中，我们必须回表才能查询到结果，那么如何优化这个过程呢？**引入正文覆盖索引**

## 覆盖索引

覆盖索引（covering index ，或称为索引覆盖）即**从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。**

## 为什么要用 B-tree

哈希表做索引，值没有排序，所以只能查找条件为等价的查询语句， 而B-tree是按顺序的，这样范围间的查询语句就很快能实现。 B-tree深度低，遍历到叶子节点速度快。

## 聚集索引与非聚集索引的区别

索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。
[聚集索引和非聚集索引的区别](https://blog.csdn.net/riemann_/article/details/90324846)

## MySQL的页

在计算机里，无论是内存还是磁盘，操作系统都是按页的大小进行读取的（页大小通常为 4 kb），磁盘每次读取都会**预读**，会提前将连续的数据读入内存中，这样就避免了多次 IO，这就是计算机中有名的**局部性原理**。即我用到一块数据，很大可能这块数据附近的数据也会被用到，干脆一起加载，省得多次 IO 拖慢速度， 这个连续数据有多大呢，必须是操作系统页大小的整数倍，这个连续数据就是 **MySQL 的页，默认值为 16 KB，也就是说对于 B+ 树的节点，最好设置成页的大小（16 KB），这样一个 B+ 树上的节点就只会有一次 IO 读。**

页大小并不是越大越好，InnoDB 是通过内存中的缓存池（pool buffer）来管理从磁盘中读取的页数据的。页太大的话，很快就把这个缓存池撑满了，可能会造成页在**内存与磁盘间频繁换入换出**，**影响性能**。

## 什么是页分裂，页合并

不符合二叉树的条件，此时就会造成**页分裂**。

![img](https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU0bsNeCdMBCbnPbjJgXgrMcP2p9jzmtdVUWq2ia6CgWdzG5hDAAH6IUNfExc3A6ygAQBZicDHMdQcg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



当我们删除 id 为 7，9 对应行的时候，上图中的索引就要更新，把 7，9 删掉，此时 8，10 就应该合到一个节点，不然 **8，10 分散在两个节点上，可能造成两次 IO 读**，势必会影响查找效率! 那什么时候会发生**页合并**呢，我们可以**定个阈值，比如对于 N 叉树来说，当节点的个数小于 N/2 的时候就应该和附近的节点合并，不过需要注意的是合并后节点里的元素大小可能会超过 N，造成页分裂，需要再对父节点等进行调整以让它满足 N 叉树的条件**。

## 为啥推荐自增 id 作为主键，自建主键不行吗

由于页分裂造成的调整必然导致性能的下降，尤其是以身份证作为主键的话，**由于身份证的随机性**，**必然造成大量的随机结点中的插入**，**进而造成大量的页分裂**，进而造成性能的急剧下降，那如果是以自增 id 作为主键呢，**由于新插入的表中生成的 id 比索引中所有的值都大，所以它要么合到已存在的节点（元素个数未满）中，要么放入新建的节点中**，所以如果是以自增 id 作为主键，就不存在页分裂的问题了。

## 怎么根据索引查找行记录

1. 主键索引直接找到行记录
2. 非主键索引回表

## limit 20000 加载很慢怎么解决

解决思路：

- 前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用 es 等进行搜索
- 使用延迟关联，即先通用 limit 得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据

```sql
select a.* from a,(select id from table_1 where is_deleted='N' limit 100000,20) b where a.id = b.id
```

- 从业务上实现，不分页如此多，例如只能分页前 100 页，后面的不允许再查了
- 不使用 limit N,M, 而是使用 limit N，即将 offset 转化为 where 条件。

## 数据库表锁和行锁

:link: [Mysql锁机制简单了解一下](https://blog.csdn.net/qq_34337272/article/details/80611486)

- **表级锁**

  Mysql中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单 **，资源消耗也比较少，加锁快，不会出现死锁** 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

- **行级锁**

  Mysql中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 **行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。**InnoDB支持的行级锁，包括如下几种。

  - **Record Lock:** 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；
  - **Gap Lock:** 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
  - **Next-key Lock：** 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。

  **虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的**：

  - 事务更新大表中的大部分数据直接使用表级锁效率更高；
  - 事务比较复杂，使用行级索很可能引起死锁导致回滚。

## MySQL 的两种锁

- **排它锁( X 锁)：** 事务 T 对数据 A 加上 X 锁时，**只允许事务 T 读取和修改数据 A。**
- **共享锁( S 锁)：** 事务 T 对数据 A 加上 S 锁时，**其他事务只能再对数据 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。**

## 数据库优化、大表优化

:link: [MySQL大表优化方案](https://segmentfault.com/a/1190000006158186)

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

#### 1. 限定数据的范围

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

#### 2. 读/写分离

经典的数据库拆分方案，主库负责写，从库负责读；

#### 3. 垂直分区

**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。 [![数据库垂直分区](https://camo.githubusercontent.com/3045b900b49be903108147297e99499ee4168b94/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545362538442541452545352542412539332545352539452538322545372539422542342545352538382538362545352538432542412e706e67)](https://camo.githubusercontent.com/3045b900b49be903108147297e99499ee4168b94/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545362538442541452545352542412539332545352539452538322545372539422542342545352538382538362545352538432542412e706e67)

- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

#### 4. 水平分区

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

[![数据库水平拆分](https://camo.githubusercontent.com/3e93efc1212224996fe7d54a89a4894ab99c853c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545362538442541452545352542412539332545362542302542342545352542392542332545362538422538362545352538382538362e706e67)](https://camo.githubusercontent.com/3e93efc1212224996fe7d54a89a4894ab99c853c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545362538442541452545352542412539332545362542302542342545352542392542332545362538422538362545352538382538362e706e67)

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案：**

- **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。
- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。

（1）根据服务层面：配置mysql性能优化参数；
（2）从系统层面增强mysql的性能：优化数据表结构、字段类型、字段索引、分表，分库、读写分离等等。
（3）从数据库层面增强性能：优化SQL语句，合理使用字段索引。
（4）从代码层面增强性能：使用缓存和NoSQL数据库方式存储，如MongoDB/Memcached/Redis来缓解高并发下数据库查询的压力。
（5）减少数据库操作次数，尽量使用数据库访问驱动的批处理方法。
（6）不常使用的数据迁移备份，避免每次都在海量数据中去检索。
（7）提升数据库服务器硬件配置，或者搭建数据库集群。
（8）编程手段防止SQL注入：使用JDBC PreparedStatement按位插入或查询；正则表达式过滤（非法字符串过滤）；

## 数据库连接池

我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**。 连接池还减少了用户必须等待建立与数据库的连接的时间。

## 一条SQL语句在MySQL中如何执行的

:link: [一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)

- MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。
- 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。
- SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎
- 对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit

## MySQL高性能优化规范建议

:link: [MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd)

## 一次 SQL 查询请求

1. **和 MySQL server 建立 TCP 连接:**

   - 三次握手

2. **MySQL 权限认证：**

   - Server 向 Client 发送 密钥

   - Client 使用密钥加密用户名、密码等信息，将加密后的报文发送给 Server
   - Server 根据 Client 请求包，验证是否是合法用户，然后给 Client 发送认证结果

3. **Client 发送 SQL 语句**

4. **Server 返回语句执行结果**

5. **MySQL 关闭**

6. **TCP 连接断开**

   - 四次挥手

可以看出不使用连接池的话，为了执行一条 SQL，会花很多时间在**安全认证、网络IO**上。

## 一条SQL语句执行得很慢的原因有哪些？

:link: [腾讯面试：一条SQL语句执行得很慢的原因有哪些？---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd)

## MySQL的日志

### redo log 与 undo log

MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中**redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础**。

**InnoDB**实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，**事务的持久性无法保证。**

**redo log**被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会**在redo log记录这次操作**；当事务提交时，会调用fsync**接口对redo log**进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了**持久性**要求。

既然redo log也需要在事务提交时将日志写入磁盘，为什么它**比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢**？主要有以下两方面的原因：

（1）**刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。**

（2）**刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。**

### redo log 与 binlog 的区别

>  binlog记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作。

1. **redo log是在InnoDB存储引擎层产生**，而**binlog是MySQL数据库的上层产生的**，并且二进制日志不仅仅针对INNODB存储引擎，MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。
2. 两种日志记录的内容形式不同。MySQL的**binlog是逻辑日志**，其记录是对应的SQL语句。而innodb存储引擎层面的 **redo log** 重做日志是**物理日志**。
3. 两种日志与记录写入磁盘的时间点不同，**二进制日志只在事务提交完成后进行一次写入**。而innodb存储引擎的重做日志**在事务进行中不断地被写入**，并且日志不是随事务提交的顺序进行写入的。
4. binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redo log是循环使用。
5. binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。

## Mysql主从复制原理

### 为什么需要主从复制？

1. 在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。

2. 做数据的热备

3. 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

### 什么是mysql的主从复制？

MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据。

### mysql复制原理

 （1）master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；

（2）slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件

（3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。

**具体步骤：**

1. 从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；  start  slave

2. 从库的IO线程和主库的dump线程建立连接。

3. 从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。

4. 主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。

5. 从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中

6. 从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge

### mysql主从形式

<img src="https://mmbiz.qpic.cn/mmbiz_png/M2gicwTVOUSdOXC8j1AN8R0Ur8j8sODnbcIm1GLF6IK5JRRy9QqPhQGJKejznCNSrUuGrAz0WyoDWc1SLuYRGLw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom: 67%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_png/M2gicwTVOUSdOXC8j1AN8R0Ur8j8sODnbbvk9mia69NdedPXOHeu9icPJV2EpW6kZhWIb74Ih1Myl0hy7STXs4KzQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:67%;" />

### mysql主从同步延时分析

mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。

解决方案：

1.业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。

2.单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。

3.服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。

4.不同业务的mysql物理上放在不同机器，分散压力。

5.使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。

6.使用更加强劲的硬件设备

### 模式划分

**STATEMENT模式（SBR） **

**记录每一条SQL修改**

- 每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一条 sql 语句和每一行的数据变化，减少了 binlog 日志量，节约IO，提高性能。
- 缺点是在某些情况下会导致 master-slave 中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)

**ROW模式（RBR） **

**仅记录修改的内容，不记录具体的SQL**

- 不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。
- 缺点是会产生大量的日志，尤其是 altertable 的时候会让日志暴涨。

**MIXED模式（MBR） **

- 以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。

## JDBC 流程

1. 加载驱动(Class.from(driverName));

2. 获取连接Connection(DriverManager.getConnection(url,userName,password));

3. 获取到Statement对象用于执行静态的SQL语句;(MySqlDAO.getStatement(),stmt.execute(sql);)

4. 执行查询返回一个结果集ResultSet并对结果集遍历以对象的方式保存到集合中;

5. 关闭资源

## delete、truncate、drop的区别

MySQL中三种**删除表的操作**

### delete

1、删除整张表的数据：

```sql
delete from table_name;
```

2、删除部分数据，添加where子句：

```sql
delete from table_name where...;
```

3、说明
　　１）、属于DML语言，**每次删除一行**，都**在事务日志中为所删除的每行记录一项**。产生**rollback**，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发，如果删除大数据量的表速度会很慢。
　　２）、**删除表中数据而不删除表的结构(定义)，同时也不释放空间**。

### truncate

1、只能操作表，将表中数据全部删除，在功能上和不带where子句的delete语句相同：

```sql
truncate table table_name;
```

2、说明
　　１)、默认情况下，truncate通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。所以使用的系统和事务日志资源少，可以使用reuse storage; truncate会将高水线复位(回到最开始)。
　　2 )、 truncate是DDL语言，**操作立即生效，自动提交，**原数据不放到rollback segment中，**不能回滚**，操作不触发trigger。
　　3 )、**删除内容、释放空间但不删除表的结构(定义)**。

### drop

1、drop语句**将删除表的结构**，以及被依赖的约束(constrain)，触发器(trigger)，索引(index)；

```sql
drop table table_name;
```

2、说明
　　1）、删除之后，依赖于该表的存储过程/函数将保留,但是变为invalid状态.
　　2）、drop也属于DDL语言，**立即执行**，执行速度最快
　　3）、**删除内容和定义，释放空间**。

